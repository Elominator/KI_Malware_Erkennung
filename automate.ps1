$CLEANUP = $true
$DIRECTORIES = @{
    Malware = ".\data\malware"
    Cleanware = ".\data\exe\cleanware"
    Shared = ".\data\shared"
    PML = ".\data\PML"
    Bin = ".\bin"
    HashedExe = ".\data\exe\hashed"
    RawCSV = ".\data\rawCSV"
    Encoded = ".\data\encoded"
    Queries = ".\data\queries"
    Classifications = ".\data\classifications"
    Categories = ".\data\categories"
}
$WSB_FILE_PATH = ".\runTest.wsb"

function Ensure-DirectoryExists {
    param ([string]$Path)
    if (-not (Test-Path -Path $Path)) {
        New-Item -ItemType Directory -Force -Path $Path | Out-Null
    }
}

function Get-Files {
    param (
        [string]$FolderPath,
        [string]$FileExtension,
        [switch]$RemoveExtension
    )
    $files = Get-ChildItem -Path $FolderPath -Filter $FileExtension
    if ($RemoveExtension) {
        return $files | ForEach-Object { $_.BaseName }
    }
    return $files
}

function Invoke-ProcessMonitor {
    param (
        [string]$Action,
        [string]$InputPath,
        [string]$OutputPath
    )
    $procmonPath = Join-Path $DIRECTORIES.Bin "ProcessMonitor\Procmon64.exe"
    $arguments = "/Quiet /AcceptEula /$Action $InputPath /SaveAs $OutputPath"
    Start-Process -FilePath $procmonPath -ArgumentList $arguments -NoNewWindow -Wait
}

function Invoke-ApiCall {
    param ([string]$Hash)
    $url = "https://mb-api.abuse.ch/api/v1/"
    $postData = "query=get_info&hash=$Hash"
    $response = Invoke-WebRequest -Uri $url -Method Post -Body $postData
    return $response.Content
}

function ConvertTo-CSV {
    param ([string]$HashName)
    $pmlPath = Join-Path $DIRECTORIES.PML "$HashName.PML"
    $outPath = Join-Path $DIRECTORIES.RawCSV "$HashName.csv"
    Invoke-ProcessMonitor -Action "Openlog" -InputPath $pmlPath -OutputPath $outPath
}

function Move-HashedFile {
    param ([string]$FilePath)
    $hash = (Get-FileHash -Path $FilePath -Algorithm SHA256).Hash.ToLower()
    $fileExtension = [System.IO.Path]::GetExtension($FilePath)
    $newFileName = "$hash$fileExtension"
    $newFilePath = Join-Path $DIRECTORIES.HashedExe $newFileName

    if (-not (Test-Path $newFilePath)) {
        Move-Item -Path $FilePath -Destination $newFilePath
        Write-Output "File $FilePath hashed and moved to $newFilePath."
    } else {
        Write-Output "File already hashed and moved."
    }
}

function Encode-CSV {
    param ([string]$HashName)
    $inputPath = Join-Path $DIRECTORIES.RawCSV "$HashName.csv"
    $outputPath = Join-Path $DIRECTORIES.Encoded "$HashName.csv"
    $exeName = if ($HashName -Match "\.msi$") { "msiexec.exe" } else { $HashName }
    $arguments = "--logfile $inputPath --encodedFile $outputPath --initProcessName $exeName --showOperation 1 --showResult 1 --showPath 1 --focusPIDs 1 --includeCategoryColumn 1 --showProcessPID 1"
    Start-Process -FilePath ".\encodeCSV.exe" -ArgumentList $arguments -NoNewWindow -Wait
}

function Initialize-Environment {
    if ($CLEANUP) {
        Get-ChildItem -Path $DIRECTORIES.Shared | Remove-Item -Force -Recurse
    }
    Copy-Item -Path "$($DIRECTORIES.Bin)\*" -Destination $DIRECTORIES.Shared -Recurse -Force
}

function Copy-FileToSharedFolder {
    param ([string]$FileToCopy)
    Initialize-Environment
    $destinationPath = Join-Path $DIRECTORIES.Shared "malware"
    Ensure-DirectoryExists $destinationPath
    Copy-Item -Path $FileToCopy -Destination $destinationPath
    Write-Host "File $($FileToCopy) copied to $destinationPath."
}

function Start-Sandbox {
    Start-Process -FilePath "C:\Windows\System32\cmd.exe" -ArgumentList "/c", $WSB_FILE_PATH
    $completedPath = Join-Path $DIRECTORIES.Shared "completed"
    while(-not (Test-Path -Path $completedPath)) {
        Start-Sleep -Seconds 5
    }
    Stop-Process -Name WindowsSandboxClient
}

function Move-PMLFile {
    param ([string]$HashFile)
    $sourcePath = Join-Path $DIRECTORIES.Shared "data\procmon.PML"
    $destPath = Join-Path $DIRECTORIES.PML "$HashFile.PML"
    Copy-Item -Path $sourcePath -Destination $destPath
}

function Process-ApiData {
    param (
        [string]$Path,
        [PSCustomObject]$ApiData
    )
    $status = $null
    $class = "Malware"
    $output = 0

    if ($ApiData.data -and $ApiData.data[0].vendor_intel.ReversingLabs) {
        $rlData = $ApiData.data[0].vendor_intel.ReversingLabs
        $status = $rlData.status
        if ($rlData.threat_name) {
            $class = ($rlData.threat_name -split "\.")[-1]
        }

        $triageScore = $ApiData.data[0].vendor_intel.Triage.score ?? 0
        $yoroiScore = $ApiData.data[0].vendor_intel.YOROI_YOMI.score ?? 0
        $filescanVerdict = $ApiData.data[0].vendor_intel.'FileScan-IO'.threatlevel ?? 0

        if ($status -in @("MALICIOUS", "SUSPICIOUS")) {
            $output = 1
            if ($yoroiScore -lt 0.4 -and $filescanVerdict -lt 0.4) {
                $output = 0
                Write-Host "Overruled: $Path - $yoroiScore $triageScore $filescanVerdict"
            }
        } elseif ($yoroiScore -gt 0.6 -and $triageScore -gt 6 -and $filescanVerdict -gt 0.5) {
            $output = 1
        }
    }

    if ($output -eq 0) { $class = "Clean" }

    $class | Out-File -FilePath (Join-Path $DIRECTORIES.Categories "$Path.class")
    $output | Out-File -FilePath (Join-Path $DIRECTORIES.Classifications "$Path.cifc")
}

foreach ($directory in $DIRECTORIES.Values) {
    Ensure-DirectoryExists $directory
}

Get-Files -FolderPath $DIRECTORIES.Cleanware | ForEach-Object {
    Write-Host $_
    Move-HashedFile $_
}

Get-Files -FolderPath $DIRECTORIES.HashedExe | ForEach-Object {
    $pmlPath = Join-Path $DIRECTORIES.PML "$($_.Name).PML"
    if (-not (Test-Path -Path $pmlPath)) {
        Write-Host "PML not found: $pmlPath"
        Copy-FileToSharedFolder $_
        Start-Sandbox
        Move-PMLFile $_.Name
        Start-Sleep -Seconds 2
    }
}

Get-Files -FolderPath $DIRECTORIES.PML -FileExtension "*.PML" -RemoveExtension | ForEach-Object {
    $rawCsvPath = Join-Path $DIRECTORIES.RawCSV "$_.csv"
    $encodedPath = Join-Path $DIRECTORIES.Encoded "$_.csv"
    
    if (-not (Test-Path -Path $rawCsvPath)) {
        Write-Host "Not converted: $_"
        ConvertTo-CSV $_
    }
    if (-not (Test-Path -Path $encodedPath)) {
        Write-Host "Not encoded: $_"
        Encode-CSV $_
    }
}

Get-Files -FolderPath $DIRECTORIES.Encoded -FileExtension "*.csv" | ForEach-Object {
    $basename = $_.BaseName
    $queryPath = Join-Path $DIRECTORIES.Queries "$basename.json"
    if (-not (Test-Path -Path $queryPath)) {
        $basename = $basename -replace ".{4}$"
        Write-Host "Not queried: $basename"
        $apiData = Invoke-ApiCall $basename
        $apiData | Out-File -FilePath $queryPath
    }
}

Get-Files -FolderPath $DIRECTORIES.Queries -FileExtension "*.json" | ForEach-Object {
    $path = $_.BaseName
    $classificationPath = Join-Path $DIRECTORIES.Classifications "$path.cifc"
    if (-not (Test-Path -Path $classificationPath)) {
        $apiData = Get-Content -Path $_.FullName -Raw | ConvertFrom-Json
        Process-ApiData -Path $path -ApiData $apiData
    }
}